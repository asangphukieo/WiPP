#!/usr/bin/env python3

""" Script for manually annotating plotted peaks.

Peaks need to be generated by the Snakemake script 'Snakefile_tr'.

"""

import os
import re
import argparse
from subprocess import Popen, PIPE
import pandas as pd


# ------------------------------------------------------------------------------
# ARGPARSER
# ------------------------------------------------------------------------------

parser = argparse.ArgumentParser(description='Annotate plotted peaks.')
parser.add_argument(
    '-v', '--viewer', default='evince',
    help='PDF viewer program (default: evince)'
)
parser.add_argument(
    '-i', '--input',
    default=os.path.join(os.getcwd(), '00_Training', '02_Visualization'),
    help='Path to visualization directory. (Default = ./00_Training/02_Visualization)'
)
parser.add_argument(
    '-o', '--output',
    default=os.path.join(os.getcwd(), '00_Training', '03_Annotation'),
    help='Path to output directory. (Default = ./00_Training/03_Annotation)'
)

# ------------------------------------------------------------------------------
# ANNOTATION
# ------------------------------------------------------------------------------

# Text displayed while annotating a single peaks
classifier_text = """
    Current Peak: {peak_curr}

    Please classify it:
        1 - Apex in left half
        2 - Compound related peak
        3 - Apex in right half

        5 - Merged Peak
        6 - Tailing/ Fronting/ Too wide
        7 - Borders too narrow

        9 - Noise/ Wrong 
    """

# Valid peak classes and corresponding integers
valid_classes = {
    '1': 'apex_left',
    '2': 'compound_related_peak',
    '3': 'apex_right',
    '5': 'merged_peak',
    '6': 'too_wide_borders',
    '7': 'too_narrow_borders',
    '9': 'noise',
}


def run_classification(vis_file_path, out_dir, pdf_cmd):
    """ Display each peak present within a file of plotted peaks, let the user
    annotate the peaks and save the annotation.

    Args:
        vis_file_path (str): Absolute or relative path to the file containing 
            information about the plotted peaks.
        out_dir (str): Absolute or relative path to the output directory.
        pdf_cmd (str): Bash command for displaying the PDFs

    Returns:
        tuple of pd.DataFrame: First element: Annotated peaks; Second element:
            number of peaks within each class

    """
    vis_file = os.path.basename(vis_file_path)
    alg, sample = re.search('(.*)__(.*)_visualization_overview.csv', vis_file) \
        .groups()

    out_file = os.path.join(out_dir, '{}__{}__annotated.csv'.format(alg, sample))
    out_file_tmp = '{}.tmp'.format(out_file)
    out_stats = os.path.join(out_dir, '{}__{}__statistics.csv'.format(alg, sample))

    # Load temp file
    if os.path.isfile(out_file_tmp):
        data = pd.read_csv(out_file_tmp, sep='\t')
    # Load already annotated file 
    elif os.path.isfile(out_file):
        data = pd.read_csv(out_file, sep='\t')
    # Generate new file
    else:
        data = pd.read_csv(vis_file_path, sep='\t')
        data['class'] = None

    data = data.sort_values(by='rt').reset_index(drop=True)

    def get_peak_str(x):
        return os.path.basename(x).replace('.pdf', ')').replace('__', ' (')

    for idx, row in data.iterrows():
        # Skip already annotated peaks
        if row['class'] and pd.notnull(row['class']):
            continue

        # Save every 10 annotated peaks
        if ((idx+1) % 10) == 0:
            data.to_csv(out_file_tmp, sep='\t', index=False)
            print('\n{st}\n*** Annotation saved ***\n{st}\n'.format(st='*'*24))
        # Print progress 
        print(
            '{}\nAnnotated peaks: {:>4} / {}\t(algorithm: {}; sample: {})' \
                .format('-'*80, idx, len(data), alg, sample)
        )
        
        file = os.path.join(
            os.path.dirname(vis_file_path), alg,
            os.path.basename(row['visualization_file'])
        )

        # Show peak PDF
        viewer_process = Popen([pdf_cmd, file], stdout=PIPE, stderr=PIPE)

        # Get user input
        while True:
            manual_class = input(
                classifier_text.format(peak_curr=get_peak_str(file))
            )
            if manual_class in valid_classes:
                break
            elif 'change' in manual_class:
                # change <IDX> to <CLASS>
                in_str = manual_class.strip().split(' ')
                try:
                    peak_idx = int(in_str[1])
                    new_class = in_str[3]
                    data.iloc[peak_idx, -1] = new_class
                    print(
                        'Changed peak {} to class {}' \
                            .format(peak_idx, new_class)
                    )
                except:
                    print('Invalid change syntax. Use: change <IDX> to <CLASS>')
            else:
                print(
                    'Only valid input: {}' \
                        .format(' | '.join(sorted(valid_classes)))
                )
        # Terminate pdf viewer process
        viewer_process.terminate()
        # Assign classes to peak
        data.at[idx, 'class'] = manual_class

    try:
        data.drop(['index', 'level_0'], axis=1, inplace=True)
    except ValueError:
        pass

    # Finale save
    data.to_csv(out_file, sep='\t', index=False)
    try:
        os.remove(out_file_tmp)
    except FileNotFoundError:
        pass

    # Output stats
    stats_data = data['class'].astype(int).value_counts().to_frame().reset_index()
    stats_data.rename(
        {'class': 'count', 'index': 'class'},
        axis='columns', inplace=True
    )
    not_annot = [
        i for i in valid_classes if not int(i) in stats_data['class'].unique()
    ]
    for not_annot_class in not_annot:
        stats_data = stats_data.append(
            {'class': int(not_annot_class), 'count': 0}, ignore_index=True
        )
    stats_data.sort_values(by='class', inplace=True)
    stats_data['description'] = [i[1] for i in sorted(valid_classes.items())]
    stats_data.to_csv(out_stats, sep='\t', index=False)
    print(stats_data)
    return (data, stats_data)


def output_final(out_dir, result, alg):
    """ Save the manually annotated peaks and the number of peaks within 
    each class to the file system.

    Args:
        out_dir (str): Absolute or relative path to the output directory.
        result (dict of str: pd.DataFrame): Containing keys 'data' and 'stats'.
            'data' value is the pd.DataFrame containing the annotated peaks
            'stats' value is the pd.DataFrame containing the numer of peaks 
                within  each class.
        alg (str): Algorithm name used for peak picking.

    """
    result['data'].to_csv(
        os.path.join(out_dir, '{}__annotated.csv'.format(alg)),
        sep='\t', index=False
    )
    result['stats'].to_csv(
        os.path.join(out_dir, '{}__statistics.csv'.format(alg)),
        sep='\t', index=False
    )


if __name__ == '__main__':
    args = parser.parse_args()
    # Get input files
    vis_overview = [
        os.path.join(args.input, i) for i in os.listdir(args.input) \
            if os.path.isfile(os.path.join(args.input, i))
    ]
    if not vis_overview:
        raise RuntimeError('No files to annotate in: {}'.format(args.input))

    if args.viewer not in ['evince', 'eog', 'open']:
        raise TypeError(
            'PDF viewer not supported: {}\nSupported are: gvfs-open|xdg-open' \
                .format(pdf_viewer)
        )

    # Create output directory
    if not os.path.isdir(args.output):
        os.makedirs(args.output)

    # Run annotation
    results = {}
    old_alg = None
    for vis_file_path in sorted(vis_overview):
        vis_file = os.path.basename(vis_file_path)
        if vis_file.startswith('00') or 'statistics' in vis_file:
            continue

        alg = vis_file.split('__')[0]
        # Safe output if all files for one algorithm are annotated
        if old_alg and alg != old_alg:
            output_final(args.output, results, old_alg)
            results = {}

        print('\nAnnotation for: {}'.format(vis_file))
        data, stats = run_classification(vis_file_path, args.output, args.viewer)
        
        try:
            results['data'] = results['data'].append(data, ignore_index=True)
            results['stats']['count'] += stats['count']
        except KeyError:
            results['data'] = data
            results['stats'] = stats  
        
        old_alg = alg
    # Safe output of last algorithm
    output_final(args.output, results, old_alg)
    print('\nAnnotation successful!\n')